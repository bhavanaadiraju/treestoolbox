% SHOW_STACK   Show maximum intensity projection of an image stack.
% (trees package)
%
% HP = show_stack (stack, options)
% --------------------------------
%
% Show the maximum intensity projections of a stack on a 3D patch (see
% "load_stack" for a description of a stack structure and see "cgui_tree"
% stk_ panel).
%
% Inputs
% ------
% - stack    ::stack structure: (see load_stack)
% - options  ::string: {DEFAULT: '-a'}
%     '-a' : axis equal
%
% Output
% ------
% - HP::handle: graphical handle to the graphics objects
%
% Example
% -------
% HP = show_stack (stack);
%
% See also load_stack
% Uses
%
% the TREES toolbox: edit, generate, visualise and analyse neuronal trees
% Copyright (C) 2009 - 2023  Hermann Cuntz

function HP = show_stack (stack, options)

if (nargin < 2) || isempty (options)
    options  = '-a'; % {DEFAULT: axis equal}
end

HP               = zeros (1, length (stack.M) * 3);
for counter      = 1 : length (stack.M)
    HP ((counter - 1) * 3 + 1) = surface ( ...
        -.5 * stack.voxel (1) + (stack.coord (counter, 1) + ...
        stack.voxel (1) * ...
        [0 size(stack.M {counter}, 2)-1; 0 size(stack.M {counter}, 2)-1]), ...
        -.5 * stack.voxel (2) + (stack.coord (counter, 2) + ...
        stack.voxel (2) * ...
        [size(stack.M {counter}, 1)-1 size(stack.M {counter}, 1)-1; 0 0]), ...
        (stack.coord (counter, 3) + zeros (2, 2)));
    set (HP ((counter - 1) * 3 + 1), ...
        'CData',               flipud (double (max ( ...
        stack.M {counter}, [], 3))), ...
        'FaceColor',           'texturemap', ...
        'Edgecolor',           'none', ...
        'facealpha',           0.5);
    HP ((counter - 1) * 3 + 2) = surface ( ...
        -.5 * stack.voxel (1) + (stack.coord (counter, 1) + ...
        stack.voxel (1) * ...
        [0 size(stack.M {counter}, 2)-1; 0  size(stack.M {counter}, 2)-1]), ...
        (stack.coord (counter, 2) + zeros (2, 2)), ...
        -.5 * stack.voxel (3) + (stack.coord (counter, 3) + ...
        stack.voxel (3) * ...
        [size(stack.M {counter}, 3)-1 size(stack.M {counter}, 3)-1; 0 0]));
    set (HP ((counter - 1) * 3 + 2), ...
        'CData',               flipud (double (squeeze (max ( ...
        stack.M {counter}, [], 1)))'), ...
        'FaceColor',           'texturemap', ...
        'Edgecolor',           'none', ...
        'facealpha',           0.5);
    HP ((counter - 1) * 3 + 3) = surface ( ...
        (stack.coord (counter, 1) + zeros (2, 2)), ...
        -.5 * stack.voxel (2) + (stack.coord (counter, 2) + ...
        stack.voxel (2) * ...
        [0 size(stack.M {counter}, 1)-1; 0  size(stack.M {counter}, 1)-1]), ...
        -.5 * stack.voxel (3) + (stack.coord (counter, 3) + ...
        stack.voxel (3) * ...
        [size(stack.M {counter}, 3)-1 size(stack.M {counter}, 3)-1; 0 0]));
    set (HP ((counter - 1) * 3 + 3), ...
        'CData',               flipud (double (squeeze (max ( ...
        stack.M {counter}, [], 2)))'), ...
        'FaceColor',           'texturemap', ...
        'Edgecolor',           'none', ...
        'facealpha',           0.5);
end

if contains (options, '-a')
    axis         equal;
end


